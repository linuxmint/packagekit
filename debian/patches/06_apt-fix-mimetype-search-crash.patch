From 80a708c59b7aa57c7ca58dddddb67767766fb077 Mon Sep 17 00:00:00 2001
From: Matthias Klumpp <matthias@tenstral.net>
Date: Wed, 8 Mar 2023 18:32:13 +0100
Subject: [PATCH] apt: Don't crash while resolving mimetypes, modernize mime
 search code

Previously we warned when there was no AppStream metadata at all by
trying to fetch all metadata and warning if we got no result.
Given the amount of data Debian and Ubuntu ship with now, this is a bad
idea (as it slows down unsuccessful searches massively), and we should
do this again only when AsPool has gained a more efficient is_empty()
method. Therefore, this check was removed for now.

In addition, we stop monitoring the pool for changes, as we will
immediately close it anyway, so the additional overhead of setting up
background reloading is not needed. Same applies for loading Flatpak
data, which we are not concerned with in PackageKit.

We also validate the package-name C string now for being NULL before
converting it into a std::string, which resolves a crash.
---
 backends/apt/apt-job.cpp | 53 +++++++++++++++++++++-------------------
 backends/apt/meson.build |  2 +-
 2 files changed, 29 insertions(+), 26 deletions(-)

diff --git a/backends/apt/apt-job.cpp b/backends/apt/apt-job.cpp
index d983374b0..0b2895350 100644
--- a/backends/apt/apt-job.cpp
+++ b/backends/apt/apt-job.cpp
@@ -1442,34 +1442,47 @@ void AptJob::providesMimeType(PkgList &output, gchar **values)
 {
     g_autoptr(AsPool) pool = NULL;
     g_autoptr(GError) error = NULL;
-    guint i;
-    vector<string> packages;
+    std::vector<string> pkg_names;
 
     pool = as_pool_new ();
-    as_pool_load (pool, NULL, &error);
-    if (error != NULL) {
-        /* we do not fail here because even with error we might still find metadata */
-        g_warning ("Issue while loading the AppStream metadata pool: %s", error->message);
-        g_error_free (error);
-        error = NULL;
+
+    /* don't monitor cache locations or load Flatpak data */
+    as_pool_remove_flags (pool, AS_POOL_FLAG_MONITOR);
+    as_pool_remove_flags (pool, AS_POOL_FLAG_LOAD_FLATPAK);
+
+    /* try to load the metadata pool */
+    if (!as_pool_load (pool, NULL, &error)) {
+        pk_backend_job_error_code(m_job,
+                                  PK_ERROR_ENUM_INTERNAL_ERROR,
+                                  "Failed to load AppStream metadata: %s", error->message);
+        return;
     }
 
-    for (i = 0; values[i] != NULL; i++) {
+    /* search for mimetypes for all values */
+    for (guint i = 0; values[i] != NULL; i++) {
         g_autoptr(GPtrArray) result = NULL;
-        guint j;
+
         if (m_cancel)
             break;
 
-        result = as_pool_get_components_by_provided_item (pool, AS_PROVIDED_KIND_MIMETYPE, values[i]);
-        for (j = 0; j < result->len; j++) {
+        result = as_pool_get_components_by_provided_item (pool, AS_PROVIDED_KIND_MEDIATYPE, values[i]);
+        for (guint j = 0; j < result->len; j++) {
+            const gchar *pkgname;
             AsComponent *cpt = AS_COMPONENT (g_ptr_array_index (result, j));
-            /* we only select one package per component - on Debian systems, AppStream components never reference multiple packages */
-            packages.push_back (as_component_get_pkgname (cpt));
+
+            /* sanity check */
+            pkgname = as_component_get_pkgname (cpt);
+            if (pkgname == NULL) {
+                g_warning ("Component %s has no package name (it was ignored in the search).", as_component_get_data_id (cpt));
+                continue;
+            }
+
+            pkg_names.push_back (pkgname);
         }
     }
 
     /* resolve the package names */
-    for (const string &package : packages) {
+    for (const std::string &package : pkg_names) {
         if (m_cancel)
             break;
 
@@ -1482,16 +1495,6 @@ void AptJob::providesMimeType(PkgList &output, gchar **values)
 
         output.append(ver);
     }
-
-    /* check if we found nothing because AppStream data is missing completely */
-    if (output.empty()) {
-        g_autoptr(GPtrArray) all_cpts = as_pool_get_components (pool);
-        if (all_cpts->len <= 0) {
-            pk_backend_job_error_code(m_job,
-                                      PK_ERROR_ENUM_INTERNAL_ERROR,
-                                      "No AppStream metadata was found. This means we are unable to find any information for your request.");
-        }
-    }
 }
 
 bool AptJob::isApplication(const pkgCache::VerIterator &ver)
diff --git a/backends/apt/meson.build b/backends/apt/meson.build
index c37f84505..d9f3f52f5 100644
--- a/backends/apt/meson.build
+++ b/backends/apt/meson.build
@@ -5,7 +5,7 @@ cpp_compiler = meson.get_compiler('cpp')
 gstreamer_dep = dependency('gstreamer-1.0')
 gstreamer_base_dep = dependency('gstreamer-base-1.0')
 gstreamer_plugins_base_dep = dependency('gstreamer-plugins-base-1.0')
-appstream_dep = dependency('appstream', version: '>=0.12')
+appstream_dep = dependency('appstream', version: '>=0.16.0')
 apt_pkg_dep = dependency('apt-pkg', version: '>=1.9.2')
 
 # Check whether apt supports ddtp
